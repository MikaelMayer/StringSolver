package ch.epfl.lara.synthesis.flashfill

object FlashFill {
  import Programs._
  import ProgramsSet._
  import Evaluator._
  implicit class AugString(s: String) {
    def e(i: Int, j: Int) = s.substring(i, j + 1)
  }
  
  type σ = IndexedSeq[String]
  type S = String
  type Output_string = String
  type Input_state = σ
  type Regular_Expression = RegExp
  type W[Node] = Map[(Node, Node), Set[SAtomicExpr]]
  
  def generateStringProgram(s: Set[(σ, S)]) = ???
  
  def generatePartition(s: Set[(σ, S)]) = ???
  
  def generateBoolClassifier(σ1: Set[σ], σ2: Set[σ]) = ???
  
  /**
   * learnd the set of all SubStr expressions
     in our language that can be used to extract a given substring
     from a given string.
   */
  def generateStr(σ: Input_state, s: Output_string, rec_loop_level: Int = 1) = {
    val ñ = (0 to s.length).toSet
    val ns = 0
    val nt = s.length
    val ξ = (for(i <- 0 to (s.length-1); j <- (i+1) to s.length) yield i->j).toSet
    val W = ξ ==> { case (i, j) =>
      generateSubString(σ, s.e(i, j-1)) ++ Set(SConstStr(s.e(i, j-1)))
    }
    val Wp =  generateLoop(σ, s, W, rec_loop_level)
    SDag(ñ, ns, nt, ξ, Wp)
  }
  
  /**
   * In this section, we discuss how to infer the set of all Loop constructors
      that can be used to generate some unknown part of a given
      output string s from a given input state σ. In the process, we would
      also identify the unknown part of the output string that the Loop
      constructor can generate. Procedure GenerateLoop performs this
      task effectively, and involves the following steps:
      1. Guess three positions within the output string k1, k2, and k3.
      2. Unify the set of trace expressions that can generate s[k1 : k2]
      with the set of trace expressions that can generate s[k2 : k3] to
      obtain a new set of string expressions, say ~e that uses the loop
      iterator w. The unification algorithm is explained below.
      3. Obtain the set of substrings obtained by running the string expressions
      ~e on input σ. If this set contains a singleton string that
      matches s[k1 : k3] for some k3, then we conclude that s[k1 : k3]
      can be generated by Loop(w : ~e). Otherwise ignore.
      The unification algorithm is same as the intersection algorithm
      except with the following replacement to Eq. 2 in Figure 4.
      IntersectPos(k1; k2) = (k2 - k1)w + k1 if k1 != k2
      The key idea above is to guess a set of loop bodies by unifying the
      sets of trace expressions associated with the substrings s[k1 : k2]
      and s[k2 : k3], and then test the validity of the conjectured set
      of loops. For performance reasons, we do not recursively invoke
      GenerateLoop (in the call that it makes to GenerateStr). This
      allows us to discover all single loops. Nested loops may be discovered
      by controlling the recursion depth.
   */
  def generateLoop(σ: Input_state, s: Output_string, W: W[Int], rec_loop_level: Int): W[Int] = {
    var Wp = W // Create a copy?
    val w = Identifier("w") // TODO : pick a fresh identifier
    for(k1 <- 0 until s.length;
        k2 <- (k1+1) until s.length;
        k3 <- (k2+1) until s.length) {
      val e1 = generateStr(σ, s.e(k1, k2))
      val e2 = generateStr(σ, s.e(k2, k3))
      val e = unify(e1, e2, w) 
      val resulting_strings = e flatMap { prog =>
        Evaluator.evalProg(prog)(σ) match {
          case StringValue(p) => List(p)
          case _ => Nil
        }
      }
      resulting_strings.toList match {
        case List(res) =>
          val k4 = res.length + k1
          if(s.e(k1, k4) == res) {
            Wp = Wp + (((k1, k4+1))->(Wp((k1, k4+1)) ++ Set(SLoop(w, e))))
          }
        case Nil =>
      }
    }
    Wp
  }
  
  def generateSubString(σ: Input_state, s: String): Set[SAtomicExpr] = ???
  
  def generatePosition(s: String, k: Int) = ???
  
  def generateRegEx(r: Regular_Expression, s: String) = ???
  //Σ
  //
  
  def IParts(s: String): Set[Token] = ???
  def Reps(s: String): Token = ???
}